 core/java/android/app/Activity.java                | 115 ++++++++++-
 core/java/android/app/ActivityManagerNative.java   |  41 ++++
 core/java/android/app/IActivityManager.java        |   8 +
 core/java/android/content/Intent.java              |   7 +
 .../inputmethodservice/InputMethodService.java     |  23 ++-
 core/java/android/view/IWindowManager.aidl         |  10 +
 packages/SystemUI/res/menu/recent_popup_menu.xml   |   1 +
 packages/SystemUI/res/values/cm_strings.xml        |   3 +
 .../android/systemui/recent/RecentsActivity.java   |   7 +
 .../android/systemui/recent/RecentsPanelView.java  | 185 +++++++++++++++++-
 .../android/internal/policy/impl/PhoneWindow.java  |   1 +
 .../internal/policy/impl/PhoneWindowManager.java   |   4 +
 .../android/server/am/ActivityManagerService.java  | 129 ++++++++++++-
 .../java/com/android/server/am/ActivityStack.java  |  17 +-
 .../android/server/wm/WindowManagerService.java    | 212 ++++++++++++++++++++-
 15 files changed, 753 insertions(+), 10 deletions(-)

diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index d6db8c2..58a0351 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -39,6 +39,7 @@ import android.content.res.TypedArray;
 import android.database.Cursor;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.media.AudioManager;
 import android.net.Uri;
@@ -65,6 +66,8 @@ import android.view.ActionMode;
 import android.view.ContextMenu;
 import android.view.ContextMenu.ContextMenuInfo;
 import android.view.ContextThemeWrapper;
+import android.view.Gravity;
+import android.view.IWindowManager;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -647,7 +650,7 @@ public class Activity extends ContextThemeWrapper
         Window.Callback, KeyEvent.Callback,
         OnCreateContextMenuListener, ComponentCallbacks2 {
     private static final String TAG = "Activity";
-    private static final boolean DEBUG_LIFECYCLE = false;
+    private static final boolean DEBUG_LIFECYCLE = true;
 
     /** Standard activity result: operation canceled. */
     public static final int RESULT_CANCELED    = 0;
@@ -764,6 +767,9 @@ public class Activity extends ContextThemeWrapper
     private Thread mUiThread;
     final Handler mHandler = new Handler();
 
+    private Rect mOriginalBounds;
+    private boolean mIsSplitView;
+
     /** Return the intent that started this activity. */
     public Intent getIntent() {
         return mIntent;
@@ -2455,6 +2461,14 @@ public class Activity extends ContextThemeWrapper
         if (ev.getAction() == MotionEvent.ACTION_DOWN) {
             onUserInteraction();
         }
+        if (mIsSplitView) {
+            IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            try {
+                wm.notifyActivityTouched(mToken, false);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot notify activity touched", e);
+            }
+        }
         if (getWindow().superDispatchTouchEvent(ev)) {
             return true;
         }
@@ -5220,12 +5234,108 @@ public class Activity extends ContextThemeWrapper
         }
         mWindowManager = mWindow.getWindowManager();
         mCurrentConfig = config;
+
+        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_SPLIT_VIEW) != 0) {
+            final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            updateSplitViewMetrics(true);
+        }
     }
 
     /** @hide */
     public final IBinder getActivityToken() {
         return mParent != null ? mParent.getActivityToken() : mToken;
     }
+
+    /** @hide */
+    public final void setSplitViewRect(int l, int t, int r, int b) {
+        final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+        /*try {
+            wm.setSplitViewRect(l,t,r,b);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Could not update split view rect", e);
+        }*/
+        updateSplitViewMetrics(false);
+    }
+
+    /** @hide */
+    public final boolean isSplitView() {
+        return mIsSplitView;
+    }
+
+    /** @hide */
+    final void updateSplitViewMetrics(boolean shouldReset) {
+        if (mParent != null) {
+            // Also update the parent activities, don't let the windows hanging
+            mParent.updateSplitViewMetrics(shouldReset);
+        }
+
+        final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+
+        try {
+            mIsSplitView = false;
+
+            if (shouldReset) {
+                wm.getSplitViewRect(getTaskId(), true);
+            }
+
+            // Check for split view settings
+            if (wm.isTaskSplitView(getTaskId())) {
+                // This activity/task is tagged as being in split view
+                mIsSplitView = true;
+
+                wm.setTaskChildSplit(mToken, true);
+
+                // Then, we apply it the position and size
+                mWindow.setGravity(Gravity.LEFT | Gravity.TOP);
+
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+
+                // We save the original window size, in case we want to restore it later
+                if (mOriginalBounds == null) {
+                    mOriginalBounds = new Rect();
+                    mOriginalBounds.left = params.x;
+                    mOriginalBounds.top = params.y;
+                    mOriginalBounds.right = params.x + params.width;
+                    mOriginalBounds.bottom = params.y + params.height;
+                }
+
+                /*try {
+                    wm.setSplitViewRect(mOriginalBounds.left, mOriginalBounds.top, mOriginalBounds.right, mOriginalBounds.bottom);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Could not update split view rect", e);
+                }*/
+
+                Rect windowBounds = wm.getSplitViewRect(getTaskId(), false);
+                mWindow.setLayout(windowBounds.right - windowBounds.left,
+                    windowBounds.bottom - windowBounds.top);
+
+                params.x = windowBounds.left;
+                params.y = windowBounds.top;
+                mWindow.setAttributes(params);
+
+                // Finally, we make the window non-modal to allow the second app to get input
+                mWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);
+                mWindow.addFlags(WindowManager.LayoutParams.FLAG_SPLIT_TOUCH);
+
+                // We notify that we are touched -- but really it's just so that this activity
+                // which just opened has the focus without the need to touch it
+                wm.notifyActivityTouched(mToken, true);
+            } else if (mOriginalBounds != null) {
+                // Restore normal window bounds
+                Log.d(TAG, "Restore original bounds from split (TaskId=" + getTaskId() + ")");
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+                params.x = mOriginalBounds.left;
+                params.y = mOriginalBounds.top;
+
+                mWindow.setLayout(mOriginalBounds.right - mOriginalBounds.left,
+                    mOriginalBounds.bottom - mOriginalBounds.top);
+
+                wm.setTaskChildSplit(mToken, false);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Could not perform split view actions on restart", e);
+        }
+    }
 
     final void performCreate(Bundle icicle) {
         onCreate(icicle);
@@ -5261,6 +5371,7 @@ public class Activity extends ContextThemeWrapper
     
     final void performRestart() {
         mFragments.noteStateNotSaved();
+        updateSplitViewMetrics(false);
 
         if (mStopped) {
             mStopped = false;
diff --git a/core/java/android/app/ActivityManagerNative.java b/core/java/android/app/ActivityManagerNative.java
index 2fcbda1..1ef8787 100644
--- a/core/java/android/app/ActivityManagerNative.java
+++ b/core/java/android/app/ActivityManagerNative.java
@@ -693,6 +693,16 @@ public abstract class ActivityManagerNative extends Binder implements IActivityM
             return true;
         }
 
+        case GET_ACTIVITY_FOR_TASK_TRANSACTION: {
+            data.enforceInterface(IActivityManager.descriptor);
+            int task = data.readInt();
+            boolean onlyRoot = data.readInt() != 0;
+            IBinder res = getActivityForTask(task, onlyRoot);
+            reply.writeNoException();
+            reply.writeStrongBinder(res);
+            return true;
+        }
+
         case REPORT_THUMBNAIL_TRANSACTION: {
             data.enforceInterface(IActivityManager.descriptor);
             IBinder token = data.readStrongBinder();
@@ -2038,6 +2048,13 @@ public abstract class ActivityManagerNative extends Binder implements IActivityM
             reply.writeNoException();
             return true;
         }
+
+        case NOTIFY_SPLIT_VIEW_LAYOUT_CHANGED: {
+            data.enforceInterface(IActivityManager.descriptor);
+            notifySplitViewLayoutChanged();
+            reply.writeNoException();
+            return true;
+        }
         }
 
         return super.onTransact(code, data, reply, flags);
@@ -2848,6 +2865,20 @@ class ActivityManagerProxy implements IActivityManager
         reply.recycle();
         return res;
     }
+    public IBinder getActivityForTask(int task, boolean onlyRoot) throws RemoteException
+    {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        data.writeInt(task);
+        data.writeInt(onlyRoot ? 1 : 0);
+        mRemote.transact(GET_ACTIVITY_FOR_TASK_TRANSACTION, data, reply, 0);
+        reply.readException();
+        IBinder res = reply.readStrongBinder();
+        data.recycle();
+        reply.recycle();
+        return res;
+    }
     public void reportThumbnail(IBinder token,
                                 Bitmap thumbnail, CharSequence description) throws RemoteException
     {
@@ -4692,5 +4723,15 @@ class ActivityManagerProxy implements IActivityManager
         reply.recycle();
     }
 
+    public void notifySplitViewLayoutChanged() throws RemoteException {
+        Parcel data = Parcel.obtain();
+        Parcel reply = Parcel.obtain();
+        data.writeInterfaceToken(IActivityManager.descriptor);
+        mRemote.transact(NOTIFY_SPLIT_VIEW_LAYOUT_CHANGED, data, reply, 0);
+        reply.readException();
+        data.recycle();
+        reply.recycle();
+    }
+
     private IBinder mRemote;
 }
diff --git a/core/java/android/app/IActivityManager.java b/core/java/android/app/IActivityManager.java
index 6477f39..0679291 100644
--- a/core/java/android/app/IActivityManager.java
+++ b/core/java/android/app/IActivityManager.java
@@ -126,6 +126,7 @@ public interface IActivityManager extends IInterface {
     public StackBoxInfo getStackBoxInfo(int stackBoxId) throws RemoteException;
     public void setFocusedStack(int stackId) throws RemoteException;
     public int getTaskForActivity(IBinder token, boolean onlyRoot) throws RemoteException;
+    public IBinder getActivityForTask(int task, boolean onlyRoot) throws RemoteException;
     /* oneway */
     public void reportThumbnail(IBinder token,
             Bitmap thumbnail, CharSequence description) throws RemoteException;
@@ -409,6 +410,9 @@ public interface IActivityManager extends IInterface {
 
     public void performIdleMaintenance() throws RemoteException;
 
+    /* SPLIT VIEW */
+    public void notifySplitViewLayoutChanged() throws RemoteException;
+
     /*
      * Private non-Binder interfaces
      */
@@ -696,4 +700,8 @@ public interface IActivityManager extends IInterface {
     int GET_PERSISTED_URI_PERMISSIONS_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+181;
     int APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+182;
     int GET_CALLING_PACKAGE_FOR_BROADCAST_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+183;
+
+    /* SPLIT VIEW */
+    int GET_ACTIVITY_FOR_TASK_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+200;
+    int NOTIFY_SPLIT_VIEW_LAYOUT_CHANGED = IBinder.FIRST_CALL_TRANSACTION+201;
 }
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 882dbfc..0f73902 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -3653,6 +3653,13 @@ public class Intent implements Parcelable, Cloneable {
      */
     public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
     /**
+     * If set in an Intent passed to {@link Context#startActivity Context.startActivity()},
+     * this flag will cause a newly launching task to be resized according to the split
+     * view metrics, making it running alongside another app.
+     * @hide
+     */
+    public static final int FLAG_ACTIVITY_SPLIT_VIEW = 0x00002000;
+    /**
      * If set, when sending a broadcast only registered receivers will be
      * called -- no BroadcastReceiver components will be launched.
      */
diff --git a/core/java/android/inputmethodservice/InputMethodService.java b/core/java/android/inputmethodservice/InputMethodService.java
index 5c48d3b..f43fbbc 100644
--- a/core/java/android/inputmethodservice/InputMethodService.java
+++ b/core/java/android/inputmethodservice/InputMethodService.java
@@ -19,6 +19,7 @@ package android.inputmethodservice;
 import static android.view.ViewGroup.LayoutParams.MATCH_PARENT;
 import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;
 
+import android.app.Activity;
 import android.app.ActivityManager;
 import android.app.Dialog;
 import android.content.Context;
@@ -39,6 +40,7 @@ import android.text.method.MovementMethod;
 import android.util.Log;
 import android.util.PrintWriterPrinter;
 import android.util.Printer;
+import android.view.IWindowManager;
 import android.view.KeyCharacterMap;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
@@ -893,7 +895,7 @@ public class InputMethodService extends AbstractInputMethodService {
      * is currently running in fullscreen mode.
      */
     public void updateFullscreenMode() {
-        boolean isFullscreen = mShowInputRequested && onEvaluateFullscreenMode();
+        boolean isFullscreen = mShowInputRequested && (onEvaluateFullscreenMode() || onEvaluateSplitView());
         boolean changed = mLastShowInputRequested != mShowInputRequested;
         if (mIsFullscreen != isFullscreen || !mFullscreenApplied) {
             changed = true;
@@ -989,6 +991,25 @@ public class InputMethodService extends AbstractInputMethodService {
         }
         return true;
     }
+
+    /**
+     * Splitview stuff - FIXME: This needs a proper doc entry
+     * @hide
+     */
+    public boolean onEvaluateSplitView() {
+        if (mCandidatesFrame.getChildCount() > 0) {
+            Context candidateContext = mCandidatesFrame.getChildAt(0).getContext();
+            if (candidateContext instanceof Activity) {
+                return ((Activity) candidateContext).isSplitView();
+            } else {
+                Log.e("XPLOD", "NOT ACTIVITY");
+                return false;
+            }
+        } else {
+            Log.e("XPLOD", "NO CHILD");
+            return false;
+        }
+    }
 
     /**
      * Controls the visibility of the extracted text area.  This only applies
diff --git a/core/java/android/view/IWindowManager.aidl b/core/java/android/view/IWindowManager.aidl
index 9dd04c4..9cf331d 100644
--- a/core/java/android/view/IWindowManager.aidl
+++ b/core/java/android/view/IWindowManager.aidl
@@ -287,4 +287,14 @@ interface IWindowManager
      * @param enabled Whether touch exploration is enabled.
      */
     void setTouchExplorationEnabled(boolean enabled);
+
+    /** SPLIT VIEW **/
+    boolean isTaskSplitView(int taskId);
+    void setTaskSplitView(int taskId, boolean split);
+    void setTaskChildSplit(IBinder token, boolean split);
+    Rect getSplitViewRect(int taskId, boolean resetLocation);
+    void notifyActivityTouched(IBinder token, boolean force);
+    void setSplitViewRect(int l, int t, int r, int b);
+
+    /** SPLIT VIEW END **/
 }
diff --git a/packages/SystemUI/res/menu/recent_popup_menu.xml b/packages/SystemUI/res/menu/recent_popup_menu.xml
index 9b6eb87..5f9a56a 100644
--- a/packages/SystemUI/res/menu/recent_popup_menu.xml
+++ b/packages/SystemUI/res/menu/recent_popup_menu.xml
@@ -18,6 +18,7 @@
 */
 -->
 <menu xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:id="@+id/recent_add_split_view" android:title="@string/status_bar_recent_add_to_split_view" />
     <item android:id="@+id/recent_remove_item" android:title="@string/status_bar_recent_remove_item_title" />
     <item android:id="@+id/recent_inspect_item" android:title="@string/status_bar_recent_inspect_item_title" />
     <item android:id="@+id/recent_force_stop" android:title="@string/advanced_dev_option_force_stop" />
diff --git a/packages/SystemUI/res/values/cm_strings.xml b/packages/SystemUI/res/values/cm_strings.xml
index 974f159..1a99506 100644
--- a/packages/SystemUI/res/values/cm_strings.xml
+++ b/packages/SystemUI/res/values/cm_strings.xml
@@ -96,6 +96,9 @@
 
     <!-- Content description of the dock battery level icon for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_dock_battery_level">Dock battery <xliff:g id="number">%d</xliff:g> percent.</string>
+
+    <!-- Title shown in recents popup for adding an application to the split view -->
+    <string name="status_bar_recent_add_to_split_view">Add to Split View</string>
 
     <!-- Screenshot delete -->
     <string name="screenshot_delete_action">Delete</string>
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
index 09a7a5e..7065bf1 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsActivity.java
@@ -175,6 +175,13 @@ public class RecentsActivity extends Activity {
         finish();
     }
 
+    public void dismissAndDoNothing() {
+        if (mRecentsPanel != null) {
+            mRecentsPanel.show(false);
+        }
+        finish();
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         getWindow().addPrivateFlags(
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
index 9c6ff96..f164f30 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
@@ -32,6 +32,11 @@ import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageDataObserver;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
 import android.content.res.TypedArray;
@@ -39,6 +44,7 @@ import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.Matrix;
 import android.graphics.Rect;
+import android.graphics.Point;
 import android.graphics.Shader.TileMode;
 import android.graphics.drawable.BitmapDrawable;
 import android.graphics.drawable.Drawable;
@@ -49,6 +55,9 @@ import android.os.UserHandle;
 import android.provider.Settings;
 import android.util.AttributeSet;
 import android.util.Log;
+import android.view.Gravity;
+import android.view.Display;
+import android.view.IWindowManager;
 import android.view.LayoutInflater;
 import android.view.MenuItem;
 import android.view.MotionEvent;
@@ -56,6 +65,8 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewPropertyAnimator;
 import android.view.ViewRootImpl;
+import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
 import android.view.accessibility.AccessibilityEvent;
 import android.view.animation.AnimationUtils;
 import android.view.animation.DecelerateInterpolator;
@@ -68,13 +79,13 @@ import android.widget.ImageView.ScaleType;
 import android.widget.PopupMenu;
 import android.widget.TextView;
 
-
 import com.android.systemui.R;
 import com.android.systemui.statusbar.BaseStatusBar;
 import com.android.systemui.statusbar.StatusBarPanel;
 import com.android.systemui.statusbar.phone.PhoneStatusBar;
 
 import java.util.ArrayList;
+import java.util.List;
 
 public class RecentsPanelView extends FrameLayout implements OnItemClickListener, RecentsCallback,
         StatusBarPanel, Animator.AnimatorListener {
@@ -102,6 +113,9 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
     private boolean mHighEndGfx;
     private ImageView mClearRecents;
 
+    private int mDragPositionX;
+    private int mDragPositionY;
+
     public static interface RecentsScrollView {
         public int numItemsInOneScreenful();
         public void setAdapter(TaskDescriptionAdapter adapter);
@@ -233,6 +247,12 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
 
             holder.thumbnailView.setTag(td);
             holder.thumbnailView.setOnLongClickListener(new OnLongClickDelegate(convertView));
+            holder.thumbnailView.setOnTouchListener(new OnTouchListener() {
+                @Override
+                public boolean onTouch(View v, MotionEvent m) {
+                    return handleThumbnailTouch(m, holder.thumbnailView);
+                }
+            });
             holder.taskDescription = td;
             return convertView;
         }
@@ -365,6 +385,58 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         }
     }
 
+    private boolean handleThumbnailTouch(MotionEvent m, View thumb) {
+        // If we have two touches, let user snap on top or bottom
+        int pointerCount = m.getPointerCount();
+        if (pointerCount == 2) {
+            int action = m.getActionMasked();
+            int currX = (int) m.getX(1);
+            int currY = (int) m.getY(1);
+
+            switch (action) {
+                case MotionEvent.ACTION_DOWN:
+                case MotionEvent.ACTION_POINTER_DOWN:
+                    mDragPositionX = currX;
+                    mDragPositionY = currY;
+                    break;
+
+                case MotionEvent.ACTION_UP:
+                    handleThumbnailDragRelease(thumb);
+                    break;
+
+                case MotionEvent.ACTION_MOVE:
+                    int diffX = currX - mDragPositionX;
+                    int diffY = currY - mDragPositionY;
+                    thumb.setTranslationX(thumb.getTranslationX() + diffX);
+                    thumb.setTranslationY(thumb.getTranslationY() + diffY);
+                    mDragPositionX = currX;
+                    mDragPositionY = currY;
+                    break;
+            }
+
+            return true;
+        } else {
+            mDragPositionX = 0;
+            mDragPositionY = 0;
+            return false;
+        }
+    }
+
+    private void handleThumbnailDragRelease(View view) {
+        ViewHolder holder = (ViewHolder) view.getTag();
+        WindowManager wm = (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        Point size = new Point();
+        display.getSize(size);
+        int width = size.x;
+        int height = size.y;
+        if (mDragPositionY < height/2) {
+            openInSplitView(holder, 0);
+        } else {
+            openInSplitView(holder, 1);
+        }
+    }
+
     protected void onAttachedToWindow () {
         super.onAttachedToWindow();
         final ViewRootImpl root = getViewRootImpl();
@@ -389,6 +461,10 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         ((RecentsActivity) mContext).dismissAndGoBack();
     }
 
+    public void dismissAndDoNothing() {
+        ((RecentsActivity) mContext).dismissAndDoNothing();
+    }
+
     public void onAnimationCancel(Animator animation) {
     }
 
@@ -462,7 +538,7 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
             mClearRecents.setOnClickListener(new OnClickListener() {
                 @Override
                 public void onClick(View v) {
-                    mRecentsContainer.removeAllViewsInLayout();
+                    ((ViewGroup) mRecentsContainer).removeAllViewsInLayout();
                 }
             });
         }
@@ -697,8 +773,19 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                         holder.thumbnailViewImage, bm, 0, 0, null).toBundle();
 
         show(false);
+
         if (ad.taskId >= 0) {
             // This is an active task; it should just go to the foreground.
+            // If that task was split viewed, a normal press wil resume it to
+            // normal fullscreen view
+            IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+            try {
+                if (DEBUG) Log.v(TAG, "Restoring window full screen after split, because of normal tap");
+                wm.setTaskSplitView(ad.taskId, false);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Could not setTaskSplitView to fullscreen", e);
+            }
+
             am.moveTaskToFront(ad.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
                     opts);
         } else {
@@ -774,6 +861,95 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
         }
     }
 
+    /**
+     * Opens the task linked in the ViewHolder in split view mode.
+     * @param holder ViewHolder of a task thumbnail
+     * @param location Where to put the split app (-1 for auto, 0 for top, 1 for bottom (the
+     * reference is a phone in portrait))
+     */
+    public void openInSplitView(ViewHolder holder, int location) {
+        if (holder != null) {
+            final Context context = holder.thumbnailView.getContext();
+            final ActivityManager am = (ActivityManager)
+                context.getSystemService(Context.ACTIVITY_SERVICE);
+            final IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+
+            TaskDescription ad = holder.taskDescription;
+
+            show(false);
+            dismissAndDoNothing();
+
+            // If we weren't on the homescreen, resize the previous activity (if not already split)
+            final List<ActivityManager.RecentTaskInfo> recentTasks =
+                am.getRecentTasks(20, ActivityManager.RECENT_IGNORE_UNAVAILABLE);
+
+            if (recentTasks != null && recentTasks.size() > 0) {
+                final PackageManager pm = mContext.getPackageManager();
+                ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME)
+                        .resolveActivityInfo(pm, 0);
+                int taskInt = 0;
+                ActivityManager.RecentTaskInfo taskInfo = recentTasks.get(1);
+                Log.e("XPLOD", "Resizing previous activity " + taskInfo.baseIntent);
+                Intent intent = new Intent(taskInfo.baseIntent);
+                if (taskInfo.origActivity != null) {
+                    intent.setComponent(taskInfo.origActivity);
+                }
+
+                ComponentName component = intent.getComponent();
+
+                if (homeInfo == null
+                    || !homeInfo.packageName.equals(component.getPackageName())
+                    || !homeInfo.name.equals(component.getClassName())) {
+                    Log.e("XPLOD", "not home intent, splitting");
+                    // This is not the home activity, so split it
+                    try {
+                        wm.setTaskSplitView(taskInfo.persistentId, true);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Could not set previous task to split view", e);
+                    }
+
+                    // We move this to front first, then our activity, so it updates
+                    am.moveTaskToFront(taskInfo.persistentId, 0, null);
+                }
+            }
+
+            if (ad.taskId >= 0) {
+                // The task is already launched. The Activity will pull its split
+                // information from WindowManagerService once it resumes, so we
+                // set its state here.
+                try {
+                    wm.setTaskSplitView(ad.taskId, true);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Could not setTaskSplitView", e);
+                }
+                am.moveTaskToFront(ad.taskId, 0, null);
+            } else {
+                // The app has been killed (we have no taskId for it), so we start
+                // a new one with the SPLIT_VIEW flag
+                Intent intent = ad.intent;
+                intent.addFlags(Intent.FLAG_ACTIVITY_SPLIT_VIEW
+                    | Intent.FLAG_ACTIVITY_NEW_TASK);
+
+                if (DEBUG) Log.v(TAG, "Starting split view activity " + intent);
+
+                try {
+                    context.startActivityAsUser(intent, null,
+                            new UserHandle(UserHandle.USER_CURRENT));
+                } catch (SecurityException e) {
+                    Log.e(TAG, "Recents does not have the permission to launch " + intent, e);
+                }
+            }
+
+            try {
+                ActivityManagerNative.getDefault().notifySplitViewLayoutChanged();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Could not notify split view layout", e);
+            }
+        } else {
+            throw new IllegalStateException("Oops, no tag on view to split!");
+        }
+    }
+
     public void handleLongPress(
             final View selectedView, final View anchorView, final View thumbnailView) {
         thumbnailView.setSelected(true);
@@ -846,6 +1022,11 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                     } else {
                         throw new IllegalStateException("Oops, no tag on view " + selectedView);
                     }
+                } else if (item.getItemId() == R.id.recent_add_split_view) {
+                    // Either start a new activity in split view, or move the current task
+                    // to front, but resized
+                    ViewHolder holder = (ViewHolder)selectedView.getTag();
+                    openInSplitView(holder, -1);
                 } else {
                     return false;
                 }
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindow.java b/policy/src/com/android/internal/policy/impl/PhoneWindow.java
index 050c9f2..3fd6cc9 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindow.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindow.java
@@ -39,6 +39,7 @@ import com.android.internal.widget.ActionBarContextView;
 import com.android.internal.widget.ActionBarOverlayLayout;
 import com.android.internal.widget.ActionBarView;
 
+import android.app.Activity;
 import android.app.KeyguardManager;
 import android.content.ComponentName;
 import android.content.ContentResolver;
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index b7e62c7..a6e7e8b 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -3502,6 +3502,10 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
     }
+
+    public Rect getContentRect() {
+        return new Rect(mContentLeft, mContentTop, mContentRight, mContentBottom);
+    }
 
     /** {@inheritDoc} */
     @Override
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index 35bfc77..0b2531f 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -7373,6 +7373,24 @@ public final class ActivityManagerService extends ActivityManagerNative
         }
     }
 
+    public IBinder getActivityForTask(int task, boolean onlyRoot) {
+        final ActivityStack mainStack = mStackSupervisor.getFocusedStack();
+        synchronized(this) {
+            ArrayList<ActivityStack> stacks = mStackSupervisor.getStacks();
+            for (ActivityStack stack : stacks) {
+                TaskRecord r = stack.taskForIdLocked(task);
+
+                if (r != null && r.getTopActivity() != null) {
+                    return r.getTopActivity().appToken;
+                } else {
+                    return null;
+                }
+            }
+        }
+        return null;
+    }
+
+
     // =========================================================
     // THUMBNAILS
     // =========================================================
@@ -14269,6 +14287,26 @@ public final class ActivityManagerService extends ActivityManagerNative
             // And we need to make sure at this point that all other activities
             // are made visible with the correct configuration.
             mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes);
+/*
+            if (mWindowManager.isTaskSplitView(starting.task.taskId)) {
+                Log.e("XPLOD", "Split view restoring task " + starting.task.taskId + " -- " + mIgnoreSplitViewUpdate.size());
+                ActivityRecord second = mainStack.topRunningActivityLocked(starting);
+                if (mWindowManager.isTaskSplitView(second.task.taskId)) {
+                    Log.e("XPLOD", "Split view restoring also task " + second.task.taskId);
+                    kept = kept && mainStack.ensureActivityConfigurationLocked(second, changes);
+                    mStackSupervisor.ensureActivitiesVisibleLocked(second, changes);
+                    if (mIgnoreSplitViewUpdate.contains(starting.task.taskId)) {
+                        Log.e("XPLOD", "Task "+ starting.task.taskId + " resuming ignored");
+                        mIgnoreSplitViewUpdate.removeAll(Collections.singleton((Integer) starting.task.taskId));
+                    } else {
+                        moveTaskToFront(second.task.taskId, 0, null);
+                        mIgnoreSplitViewUpdate.add(starting.task.taskId);
+                        mIgnoreSplitViewUpdate.add(second.task.taskId);
+                        mStackSupervisor.resumeTopActivitiesLocked();
+                        moveTaskToFront(starting.task.taskId, 0, null);
+                    }
+                }
+            }*/
         }
 
         if (values != null && mWindowManager != null) {
@@ -14278,6 +14316,8 @@ public final class ActivityManagerService extends ActivityManagerNative
         return kept;
     }
 
+private ArrayList<Integer> mIgnoreSplitViewUpdate = new ArrayList<Integer>();
+
     /**
      * Decide based on the configuration whether we should shouw the ANR,
      * crash, etc dialogs.  The idea is that if there is no affordnace to
@@ -15500,8 +15540,61 @@ public final class ActivityManagerService extends ActivityManagerNative
                 reportingProcessState, now);
     }
 
+    private ArrayList<Integer> mIgnoreSplitViewUpdateResume = new ArrayList<Integer>();
+
     private final ActivityRecord resumedAppLocked() {
-        return mStackSupervisor.resumedAppLocked();
+        final ActivityRecord starting = mStackSupervisor.resumedAppLocked();
+
+        final long origId = Binder.clearCallingIdentity();
+
+        if (mSecondTaskToResume >= 0) {
+            /*moveTaskToFront(mSecondTaskToResume, 0, null);
+            mStackSupervisor.resumeTopActivitiesLocked();
+            moveTaskToFront(starting.task.taskId, 0, null);
+            mStackSupervisor.resumeTopActivitiesLocked();*/
+            moveTaskToFront(mSecondTaskToResume, 0, null);
+            mStackSupervisor.resumeTopActivitiesLocked();
+            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
+            mIgnoreSplitViewUpdateResume.add(mSecondTaskToResume);
+
+            if (mIgnoreSplitViewUpdateResume.contains((Integer) starting.task.taskId)) {
+                mSecondTaskToResume = -1;
+            } else {
+                mSecondTaskToResume = starting.task.taskId;
+            }
+        }
+
+/*
+        if (mWindowManager != null && starting != null &&
+                mWindowManager.isTaskSplitView(starting.task.taskId)) {
+            Log.e("XPLOD", "[rAL] The current resumed task " + starting.task.taskId + " is split. Checking second");
+
+            // This task was split, we resume the second task if this task wasn't already a resumed task
+            if (mIgnoreSplitViewUpdateResume.contains(starting.task.taskId)) {
+                Log.e("XPLOD", "[rAL] This task (" + starting.task.taskId + ") was called from a split-initiated resume. Ignoring.");
+                mIgnoreSplitViewUpdateResume.remove((Integer) starting.task.taskId);
+            } else {
+                ActivityRecord second = getFocusedStack().topRunningActivityLocked(starting);
+
+                // Is that second task split as well?
+                if (mWindowManager.isTaskSplitView(second.task.taskId)) {
+                    // Don't restore me again
+                    mIgnoreSplitViewUpdateResume.add((Integer) second.task.taskId);
+                    mIgnoreSplitViewUpdateResume.add((Integer) starting.task.taskId);
+                    Log.e("XPLOD", "[rAL] There is a second task that I should be ignoring next: " + second.task.taskId);
+                    moveTaskToFront(second.task.taskId, 0, null);
+                    mStackSupervisor.resumeTopActivitiesLocked();
+                    mIgnoreSplitViewUpdateResume.add((Integer) second.task.taskId);
+                    mIgnoreSplitViewUpdateResume.add((Integer) starting.task.taskId);
+                    moveTaskToFront(starting.task.taskId, 0, null);
+                }
+            }
+        }
+*/
+
+        Binder.restoreCallingIdentity(origId);
+
+        return starting;
     }
 
     final boolean updateOomAdjLocked(ProcessRecord app) {
@@ -16751,4 +16844,38 @@ public final class ActivityManagerService extends ActivityManagerNative
         info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
         return info;
     }
+
+    private int mSecondTaskToResume = -1;
+
+    public void notifySplitViewLayoutChanged() {
+        final long origId = Binder.clearCallingIdentity();
+
+        ActivityRecord starting = getFocusedStack().topRunningActivityLocked(null);
+
+        if (mWindowManager != null && starting != null &&
+                mWindowManager.isTaskSplitView(starting.task.taskId)) {
+            Log.e("XPLOD", "[rAL] The current resumed task " + starting.task.taskId + " is split. Checking second");
+
+            // This task was split, we resume the second task if this task wasn't already a resumed task
+            if (mIgnoreSplitViewUpdateResume.contains(starting.task.taskId)) {
+                Log.e("XPLOD", "[rAL] This task (" + starting.task.taskId + ") was called from a split-initiated resume. Ignoring.");
+                mIgnoreSplitViewUpdateResume.remove((Integer) starting.task.taskId);
+            } else {
+                ActivityRecord second = getFocusedStack().topRunningActivityLocked(starting);
+
+                // Is that second task split as well?
+                if (mWindowManager.isTaskSplitView(second.task.taskId)) {
+                    // Don't restore me again
+                    //mIgnoreSplitViewUpdateResume.add((Integer) second.task.taskId);
+                    Log.e("XPLOD", "[rAL] There is a second task that I should be ignoring next: " + second.task.taskId);
+                    /*moveTaskToFront(second.task.taskId, 0, null);
+                    mStackSupervisor.resumeTopActivitiesLocked();
+                    mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);*/
+                    mSecondTaskToResume = second.task.taskId;
+                }
+            }
+        }
+
+        Binder.restoreCallingIdentity(origId);
+    }
 }
diff --git a/services/java/com/android/server/am/ActivityStack.java b/services/java/com/android/server/am/ActivityStack.java
index 0294136..78178de 100755
--- a/services/java/com/android/server/am/ActivityStack.java
+++ b/services/java/com/android/server/am/ActivityStack.java
@@ -76,9 +76,12 @@ import android.os.Trace;
 import android.os.UserHandle;
 import android.text.TextUtils;
 import android.util.EventLog;
+import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
 import com.android.internal.app.ActivityTrigger;
+import android.view.IWindowManager;
+import android.view.WindowManagerGlobal;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -1116,13 +1119,11 @@ final class ActivityStack {
                                 mStackSupervisor.startSpecificActivityLocked(r, false, false);
                             }
                         }
-
                     } else if (r.visible) {
                         // If this activity is already visible, then there is nothing
                         // else to do here.
                         if (DEBUG_VISBILITY) Slog.v(TAG, "Skipping: already visible at " + r);
                         r.stopFreezingScreenLocked(false);
-
                     } else if (onlyThisProcess == null) {
                         // This activity is not currently visible, but is running.
                         // Tell it to become visible.
@@ -1153,7 +1154,16 @@ final class ActivityStack {
                     // Aggregate current change flags.
                     configChanges |= r.configChangeFlags;
 
-                    if (r.fullscreen) {
+                    boolean isSplitView = false;
+
+                    try {
+                        IWindowManager wm = (IWindowManager) WindowManagerGlobal.getWindowManagerService();
+                        isSplitView = wm.isTaskSplitView(r.task.taskId);
+                    } catch (RemoteException e) {
+                        Slog.e(TAG, "Cannot get split view status", e);
+                    }
+
+                    if (r.fullscreen && !isSplitView) {
                         // At this point, nothing else needs to be shown
                         if (DEBUG_VISBILITY) Slog.v(TAG, "Fullscreen: at " + r);
                         behindFullscreen = true;
@@ -1260,6 +1270,7 @@ final class ActivityStack {
      * nothing happened.
      */
     final boolean resumeTopActivityLocked(ActivityRecord prev) {
+		Log.e("XPLOD", "Resume Top Activity Locked " + prev);
         return resumeTopActivityLocked(prev, null);
     }
 
diff --git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java
index 70abc4f..dbebf3f 100644
--- a/services/java/com/android/server/wm/WindowManagerService.java
+++ b/services/java/com/android/server/wm/WindowManagerService.java
@@ -48,6 +48,7 @@ import com.android.server.power.ShutdownThread;
 
 import android.Manifest;
 import android.app.ActivityManager.StackBoxInfo;
+import android.app.ActivityManager;
 import android.app.ActivityManagerNative;
 import android.app.IActivityManager;
 import android.app.StatusBarManager;
@@ -153,6 +154,7 @@ import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.List;
 
 /** {@hide} */
@@ -810,6 +812,12 @@ public class WindowManagerService extends IWindowManager.Stub
         // Add ourself to the Watchdog monitors.
         Watchdog.getInstance().addMonitor(this);
 
+        mSplitViewTasks = new int[2];
+        mNextSplitViewLocation = 0;
+        mIsTaskSplitted = new HashMap<Integer, Boolean>();
+        mTaskLocation = new HashMap<Integer, Integer>();
+        mIsTokenSplitted = new HashMap<IBinder, Boolean>();
+
         SurfaceControl.openTransaction();
         try {
             createWatermarkInTransaction();
@@ -9924,7 +9932,28 @@ public class WindowManagerService extends IWindowManager.Stub
 
             if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: Found new focus @ " + i +
                         " = " + win);
-            return win;
+
+            // Dispatch to this window if it is wants key events.
+            if (win.canReceiveKeys()) {
+                if (mFocusedApp != null) {
+                    if (mIsTokenSplitted.containsKey(mFocusedApp.token) && mIsTokenSplitted.get(mFocusedApp.token)) {
+                        if ((mTaskTouched != null && mTaskTouched.equals(mFocusedApp.token)) || mTaskTouched == null) {
+                            if (DEBUG_FOCUS) Slog.v(
+                                TAG, "Found focus @ " + i + " = " + win);
+                            return win;
+                        } else {
+                            if (DEBUG_FOCUS || localLOGV) Slog.v(
+                                TAG, "Task " + win + " is split, but not last touched");
+                        }
+                    } else {
+                        if (DEBUG_FOCUS) Slog.v(TAG, "Task " + win + " has no split token");
+                        return win;
+                    }
+                } else {
+                    if (DEBUG_FOCUS) Slog.v(TAG, "Null thisApp");
+                    return win;
+                }
+            }
         }
 
         if (DEBUG_FOCUS_LIGHT) Slog.v(TAG, "findFocusedWindow: No focusable windows.");
@@ -10926,4 +10955,185 @@ public class WindowManagerService extends IWindowManager.Stub
     public void addSystemUIVisibilityFlag(int flag) {
         mLastStatusBarVisibility |= flag;
     }
+
+    /** SPLIT VIEW **/
+
+    private int mSplitViewTasks[];
+    private int mNextSplitViewLocation;
+    private Map<Integer, Boolean> mIsTaskSplitted;
+    private Map<IBinder, Boolean> mIsTokenSplitted;
+    private Map<Integer, Integer> mTaskLocation;
+    private IBinder mTaskTouched;
+    private Rect mSplitViewRect = new Rect();
+
+    /**
+     * Returns whether or not the provided taskId is in split view mode
+     * or not. Remember that the taskId is shared between all activities
+     * of an app, thus children activities from the root one shares the
+     * same taskId.
+     *
+     * @param taskId The task id of the activity
+     * @return True if the task is in split view mode
+     */
+    public boolean isTaskSplitView(int taskId) {
+        if (mIsTaskSplitted.containsKey(taskId)) {
+            return mIsTaskSplitted.get(taskId);
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Sets whether or not a task should be in split view or not. The
+     * update only occurs when activities performs a resume or restart
+     * operation.
+     *
+     * @param taskId The task id of the activity
+     * @param split True to enable split mode, false otherwise
+     */
+    public void setTaskSplitView(int taskId, boolean split) {
+        mIsTaskSplitted.put(taskId, split);
+        try {
+            mIsTokenSplitted.put(mActivityManager.getActivityForTask(taskId, false), split);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Cannot retrieve activity token for task " + taskId, e);
+        }
+    }
+
+    /**
+     * Notifies the WindowManager that the provided token is split
+     * or not. This is useful because children activities don't share
+     * the same token, so Activity can notify the window token is split
+     * as well based on the taskId it reads during performRestart.
+     *
+     * @param token The activity token
+     * @param split True if the token should be split
+     */
+    public void setTaskChildSplit(IBinder token, boolean split) {
+        mIsTokenSplitted.put(token, split);
+    }
+
+    /**
+     * Notifies that the provided activity token has been touched, and
+     * sets the focus to that activity, and move it to the front so it
+     * gets updated properly.
+     *
+     * @param token The activity token
+     * @param force Set this to true to force the focus update even if the
+     *              application was already focused
+     */
+    public void notifyActivityTouched(IBinder token, boolean force) {
+        mTaskTouched = token;
+        synchronized(mWindowMap) {
+            boolean changed = false;
+            if (token != null) {
+                AppWindowToken newFocus = findAppWindowToken(token);
+                if (newFocus == null) {
+                    Slog.w(TAG, "Attempted to set focus to non-existing app token: " + token);
+                    return;
+                }
+                changed = mFocusedApp != newFocus;
+                mFocusedApp = newFocus;
+                if (changed || force) {
+                    if (DEBUG_FOCUS) Slog.v(TAG, "Changed app focus to " + token);
+                    mInputMonitor.setFocusedAppLw(newFocus);
+                }
+            }
+
+            if (changed || force) {
+                final long origId = Binder.clearCallingIdentity();
+                updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL, true);
+                mH.removeMessages(H.REPORT_FOCUS_CHANGE);
+                mH.sendEmptyMessage(H.REPORT_FOCUS_CHANGE);
+                Binder.restoreCallingIdentity(origId);
+            }
+        }
+
+        // We only move the activity to front if it's not already the focused app.
+        // Not doing so causes a huge lag when opening an app in split view, because
+        // it is moved to front while starting.
+        if (!force) {
+            final long origId = Binder.clearCallingIdentity();
+            try {
+                mActivityManager.moveTaskToFront(mActivityManager.getTaskForActivity(token, false), 0, null);
+                Log.e("XPLOD", "Moved activity to front because TOUCH!");
+            } catch (RemoteException e) {
+                Log.e(TAG, "Cannot move the activity to front", e);
+            }
+            Binder.restoreCallingIdentity(origId);
+        }
+    }
+
+    public void setSplitViewRect(int l, int t, int r, int b) {
+        Log.e("XPLOD", "Set split view rect ("+l+","+t+","+r+","+b+")");
+        mSplitViewRect.left = l;
+        mSplitViewRect.top = t;
+        mSplitViewRect.right = r;
+        mSplitViewRect.bottom = b;
+    }
+
+    /**
+     * Computes and return the final window metrics for the provided
+     * taskId. It will automatically set the task to the split mode.
+     *
+     * @param taskId The id of the task
+     * @param resetLocation True to reset the location to the next available spot
+     * @return A rect of the final window metrics
+     */
+    public Rect getSplitViewRect(int taskId, boolean resetLocation) {
+		Log.e("XPLOD", "Debug Activity " + taskId + " asked for split view rect");
+        mSplitViewTasks[mNextSplitViewLocation] = taskId;
+        mIsTaskSplitted.put(taskId, true);
+
+        // TODO(multidisplay): For now, apply Configuration to main screen only.
+        final DisplayContent displayContent = getDefaultDisplayContentLocked();
+
+        // Use the effective "visual" dimensions based on current rotation
+        final boolean rotated = (mRotation == Surface.ROTATION_90
+                || mRotation == Surface.ROTATION_270);
+        final int realdw = rotated ?
+                displayContent.mBaseDisplayHeight : displayContent.mBaseDisplayWidth;
+        final int realdh = rotated ?
+                displayContent.mBaseDisplayWidth : displayContent.mBaseDisplayHeight;
+	 final boolean nativeLandscape =
+                (displayContent.mBaseDisplayHeight < displayContent.mBaseDisplayWidth);
+
+        int dw = realdw;
+        int dh = realdh;
+
+
+        // Get application display metrics.
+        final int appWidth = /*((PhoneWindowManager) mPolicy).getContentRect().right - ((PhoneWindowManager) mPolicy).getContentRect().left;//*/ mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation);
+        final int appHeight = /*((PhoneWindowManager) mPolicy).getContentRect().bottom - ((PhoneWindowManager) mPolicy).getContentRect().top;//*/mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation);
+
+        int location = mNextSplitViewLocation;
+        if (mTaskLocation.containsKey(taskId)) {
+            location = mTaskLocation.get(taskId);
+        } else {
+            if (mNextSplitViewLocation == 0) {
+                mNextSplitViewLocation = 1;
+            } else {
+                mNextSplitViewLocation = 0;
+            }
+        }
+
+        mTaskLocation.put(taskId, location);
+
+        if (location == 0) {
+            if (nativeLandscape ^ rotated) {
+                return new Rect(0, 0, appWidth/2, appHeight);
+            } else {
+                return new Rect(0, 0, appWidth, appHeight/2);
+            }
+        } else {
+            if (nativeLandscape ^ rotated) {
+                return new Rect(appWidth/2, 0, appWidth, appHeight);
+            } else {
+                return new Rect(0, appHeight/2, appWidth, appHeight);
+            }
+        }
+
+    }
+
+    /** END SPLIT VIEW **/
 }
